

#ProfileFunctions( [ DebugNewImageOfBarDifferential, NewTensorProductOfGradedAlgebraNTimes, NewTensorProductOfGradedAlgebras, NewHOMGrading ] );



NewGradingOfAlgebra:= function( A )    #This function assumes that the ideal generated by rels intersects kQ_0 trivially and that rels is a set of homogeneous relations of kQ
	local d, Counter, I, kQ, rels, DimTotal, DimOfComponents, gens, Grade ;
	d:= NewDictionary( fail, true, Integers );
	DimTotal:= Dimension( A );
	DimOfComponents:= [ ];
	Counter:= 0 ;
	while Sum( DimOfComponents ) < DimTotal do
		gens:= OrderedPathsOfLengthN( A, Counter );
		Grade:= Subspace( A, gens );
		AddDictionary( d, Counter, Grade );
		Add( DimOfComponents, Dimension( Grade ) );
		Counter:= Counter + 1;
	od;
	if Sum( DimOfComponents ) = DimTotal then
		return [ A,  d ] ;
	else
		return [ A, d, "The relations may not be homogeneous" ];
	fi;
end;


############################################################################################################################################################################################

NewSubspacesToTensorProduct:= function( AB, Ai, Bj, A, B ) #Takes subspaces Ai of A and Bj of B and returns the subspace Ai \otimes Bj of AB = A \otimes B
	local BasisAi, BasisBj, TensorBasis, iter, P, s, TensorSubspace ;
	BasisAi:= Basis( Ai );
	BasisBj:= Basis( Bj );
	TensorBasis:= [ ];
	iter:= IteratorOfCartesianProduct( BasisAi, BasisBj );
	for P in iter do
		s:= CustomSimpleTensor( [ P[1], P[2] ], AB, A, B );
		Add( TensorBasis, s );
	od;
	TensorSubspace:= Subspace( AB, TensorBasis );
	return TensorSubspace ;
end;


NewnthGradeTensorProduct:= function( AB, GradedA, GradedB, n )
	local A, B, ListA, ListB, iter, P, GradedPart, nthGradeList, nthGrade ;
	nthGradeList:= [ ];
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	iter:= IteratorOfCartesianProduct( ListA, ListB );
	for P in iter do
		if P[1][2] + P[2][2] = n then
			GradedPart:= NewSubspacesToTensorProduct( AB, P[1][1], P[2][1], A, B );
			Add( nthGradeList, GradedPart );
		else
			continue;
		fi;
	od;
	nthGrade:= Sum( nthGradeList );
	return nthGrade;
end;


NewTensorProductOfGradedAlgebras:= function( GradedA, GradedB ) #AB is the tensor product of A and B, GradedA is a list [ A, L ], where L is the list outputted by NewGradingOfAlgebraByRels( kQ, rels )
	local A, B, AB, DimAB, ListA, ListB, GradesA, GradesB, x1, x2, x3, x4, iter, cart, IndexList, ABmin, ABmax, ABGrades, nthGrade ;
	A:= GradedA[1]; B:= GradedB[1];
	AB:= AlgebraTensorProduct( A, B );
	DimAB:= Dimension( AB );
	ListA:= GradedA[2]; GradesA:= [ ];
	ListB:= GradedB[2]; GradesB:= [ ];
	for x1 in ListA do
		Add( GradesA, x1[2] );
	od;
	for x2 in ListB do
		Add( GradesB, x2[2] );
	od;
	cart:= Cartesian( GradesA, GradesB );
	IndexList:= [ ];
	for x3 in cart do
		Add( IndexList, Sum( x3 ) );
	od;
	ABmin:= Minimum( IndexList );
	ABmax:= Maximum( IndexList );
	ABGrades:= [ ];
	for x4 in [ABmin..ABmax] do
		nthGrade:= NewnthGradeTensorProduct( AB, GradedA, GradedB, x4 );
		Add( ABGrades, [ nthGrade, x4 ] );
	od;
	return [ AB, ABGrades ];
end;


NewTensorProductOfGradedAlgebraNTimes:= function( GradedA, n) 	#GradedA is a list of the form [ A, L ], where L is the grading of A.
	local TProduct, LesserTensorProduct, LLesser, K;
	if n = 0 then
		K:= LeftActingDomain( GradedA[1] );
		return [ K, [ [ K, 0 ] ] ];
	elif n = 1 then
		return GradedA ;
	elif n = 2 then
		TProduct:= NewTensorProductOfGradedAlgebras( GradedA, GradedA );
		return TProduct;
	elif n > 2 then
		TProduct:= NewTensorProductOfGradedAlgebras( NewTensorProductOfGradedAlgebraNTimes( GradedA, n-1 ), GradedA );
		return TProduct ;
	else
		Print("what are you doing");
	fi;
end;



#################################################################################################################################################################################


HomSpaceBasis:= function( GradedA, GradedB, Ai, Bj)  #Returns a basis for the subspace Hom(Ai, Bj) of Hom(A, B), without explicitly computing the subspace
	local x1, i, A, B, bA, bAi, bBj, cart, L, f, HomBase ;
	A:= GradedA[1]; B:= GradedB[1];
	bA:= BasisForGradedAlgebra( GradedA ); bAi:= Basis( Ai );																					#We have as an assumption that Basis( Ai ) is a subset of Basis( A )
	bBj:= Basis( Bj );
	cart:= IteratorOfCartesianProduct( bAi, bBj );
	HomBase:= [ ];
	for x1 in cart do
		i:= Position( bA, x1[1] );
		L:= [];
		CopyListEntries( [ Zero( B ) ], 1, 0, L, 1, 1, Length( Basis( A ) ) );    #This is to define the map sending the basis element x1[1] to x1[2], and all
		L[i]:= x1[2];																															#other basis elements to 0
		f:= LeftModuleHomomorphismByImages( A, B, bA, L );
		Add( HomBase, f );
	od;
	return HomBase;
end;



NewExtendedHomSpace:= function( HomAB, GradedA, GradedB, Ai, Bj )				#Takes a Hom set Hom(Ai, Bj) and considers it as a subspace of Hom(A, B)
	local i, x1, f, A, B, BaseAi, BaseBj, cart, L, SubHomBase;
	A:= GradedA[1]; B:= GradedB[1];
	BaseAi:= Basis( Ai ); BaseBj:= Basis( Bj );
	cart:= IteratorOfCartesianProduct( BaseAi, BaseBj );
end;


NewnthGradedHom:= function( K, HomAB, GradedA, GradedB, n )   #This function outputs the nth graded Hom set Hom( A, B )_n of linear maps A -> B of degree n
	local i, x1, f, A, B, ListA, ListB, BaseHomAB, nListB, RestrictedSubspaceGens, HomSubspace, SummandList;
	A:= GradedA[1]; ListA:= GradedA[2]; BaseHomAB:= Basis( HomAB );
	B:= GradedB[1]; ListB:= GradedB[2];
	nListB:= [ ];
	for x1 in ListA do
		Add( nListB, GradedPositionFinder( GradedB, n + x1[2] ) );
	od;
	SummandList:= [ ];
	for i in [1..Length( ListA )] do
		RestrictedSubspaceGens:= HomSpaceBasis( GradedA, GradedB, ListA[i][1], nListB[i] );
		HomSubspace:= Subspace( HomAB, RestrictedSubspaceGens );
		Add( SummandList, HomSubspace );
	od;
	return Sum( SummandList );
end;

#NewnthGradedHom:= function( K, HomAB, GradedA, GradedB, n )   #This function outputs the nth graded Hom set Hom( A, B )_n of linear maps A -> B of degree n
#	local i, x1, f, A, B, ListA, ListB, BaseHomAB, nListB, RestrictedSubspaceGens, HomSubspace, SummandList;
#	A:= GradedA[1]; ListA:= GradedA[2]; #BaseHomAB:= Basis( HomAB );
#	B:= GradedB[1]; ListB:= GradedB[2];
#	nListB:= [ ];
#	for x1 in ListA do
#		Add( nListB, GradedPositionFinder( GradedB, n + x1[2] ) );
#	od;
#	SummandList:= [ ];
#	for i in [1..Length( ListA )] do
#		RestrictedSubspaceGens:= HomSpaceBasis( A, B, ListA[i][1], nListB[i] );
#		HomSubspace:= VectorSpace(K, RestrictedSubspaceGens );
#		Add( SummandList, HomSubspace );
#	od;
#	return Sum( SummandList );
#end;

NewHOMGrading:= function( K, GradedA, GradedB ) #This function returns the grading of HOM(A, B) = \bigoplus_{n \in \mathbb{Z}} Hom(A, B)_n
	local n, x1, x2, x3, x4, x5, A, B, HomAB, ListA, ListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, MaxCounter, MinCounter, HOMMax, HOMMin, HomGrades, nGrade ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	HomAB:= Hom( K, A, B );
	IndexA:= [ ]; IndexB:= [ ];
#
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	HOMMax:= Bmax - Amin; HOMMin:= Bmin - Amax;
	HomGrades:= [ ];
	for n in [HOMMin..HOMMax] do
		nGrade:= NewnthGradedHom( K, HomAB, GradedA, GradedB, n );
		Add( HomGrades, [ nGrade, n ] );
	od;
	return [ HomAB, HomGrades ];
end;


#################################################################################################################################################################################



NewImageOfBarDifferential:= function( f, n, A, An1, An )  #f is a linear map An -> A, for An the n-fold tensor product of A
	local j1, j2, i, x, L, BaseA, BaseATuples, ImagesbfList, nOfA, n1OfA, elmt, summand, bfSummand, bf, BaseAn1;
	BaseA:= Basis( A );
	BaseATuples:= Tuples( BaseA, n + 1 );
	ImagesbfList:= [ ];
	nOfA:= [ ];
	n1OfA:= [ ];
	for j1 in [1..n] do
		Add( nOfA, A );
	od;
	for x in BaseATuples do
		L:= [ x[1] * Image( f, nCustomSimpleTensor( x{[2..n+1]}, An, nOfA ) ) ];
		for i in [1..n] do
			elmt:= Concatenation( x{[1..(i-1)]}, [ x[i] * x[i+1] ], x{[(i+2)..(n+1)]} );
			summand:= nCustomSimpleTensor( elmt, An, nOfA );
			bfSummand:= ((-1)^i ) * Image( f, summand );
			Add( L, bfSummand );
		od;
		Add( L, ((-1)^(n+1)) * Image( f, nCustomSimpleTensor( x{[1..n]}, An, nOfA ) ) * x[n+1] );
		Add( ImagesbfList, Sum( L ) );
	od;
	BaseAn1:= Basis( An1 );
	bf:= LeftModuleHomomorphismByImages( An1, A, BaseAn1, ImagesbfList );
	return bf;
end;

NewBarDifferential:= function( GradedA, n ) #Need to fix the indexing and the n = 1 case, since b_n: Hom(A^{\otimes n-1}, A) -> Hom(A^{\otimes n}, A)
	local A, An, An1, GradedAn, GradedAn1, HomAn, HomAn1, GradedHomAn, GradedHomAn1, ImageList, BaseHomAn, bImage, f, b;
	if n > 0 or n = 0 then
		A:= GradedA[1];
		GradedAn:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n + 1 ); An:= GradedAn[1];
		GradedAn1:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n + 2 ); An1:= GradedAn1[1];
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= NewHOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn:= Basis( HomAn );
		ImageList:= [ ];
		for f in BaseHomAn do
			bImage:= NewImageOfBarDifferential( f, n + 1, A, An1, An );
			Add( ImageList, bImage );
		od;
		b:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList );
		return [ GradedHomAn, b, GradedHomAn1 ];
	else
		Print("Put in a correct number, dummy");
	fi;
end;


NewCoHHomologyMaps2:= function( GradedA, n )
	local f, g, GradedAn0, GradedAn, GradedAn1, A, An0, An, An1, GradedHomAn0, GradedHomAn, GradedHomAn1, HomAn0, HomAn, HomAn1, BaseHomAn0, BaseHomAn, ImageList1, ImageList2, bImage, b, bn0, bn;
	if n > 0 then
		A:= GradedA[1];
#b_n: Hom( A^{n-1}, A ) -> Hom( A^{n}, A )#
		GradedAn0:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n ); An0:= GradedAn0[1];
		GradedAn:= NewTensorProductOfGradedAlgebras( GradedAn0, GradedA ); An:= GradedAn[1];
		GradedAn1:= NewTensorProductOfGradedAlgebras( GradedAn, GradedA ); An1:= GradedAn1[1];
		GradedHomAn0:= NewHOMGrading( LeftActingDomain( A ), GradedAn0, GradedA ); HomAn0:= GradedHomAn0[1];
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= NewHOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn0:= Basis( HomAn0 );
		BaseHomAn:= Basis( HomAn );
		ImageList1:= [ ]; ImageList2:= [ ];
		for f in BaseHomAn0 do
			bImage:= NewImageOfBarDifferential( f, n, A, An, An0 );
			Add( ImageList1, bImage );
		od;
		bn0:= LeftModuleHomomorphismByImages( HomAn0, HomAn, BaseHomAn0, ImageList1 );
		for g in BaseHomAn do
			bImage:= NewImageOfBarDifferential( g, n+1, A, An1, An );
			Add( ImageList2, bImage );
		od;
		bn:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList2 );
		return [ bn, bn0, GradedHomAn0, GradedHomAn, GradedHomAn1 ];
	elif n = 0 then
		b:= NewBarDifferential( GradedA, 0 )[2];
		return b;
	else
		Print("Enter a nonnegative integer");
	fi;
end;


#################################################################################################################################################################################

#This code is a mess, I'm sorry


DebugNewBarDifferential:= function( GradedA, n ) #Need to fix the indexing and the n = 1 case, since b_n: Hom(A^{\otimes n-1}, A) -> Hom(A^{\otimes n}, A)
	local A, An, An1, GradedAn, GradedAn1, HomAn, HomAn1, GradedHomAn, GradedHomAn1, ImageList, BaseHomAn, bImage, f, b;
	if n > 0 or n = 0 then
		A:= GradedA[1];
		GradedAn:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n + 1 ); An:= GradedAn[1];
		GradedAn1:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n + 2 ); An1:= GradedAn1[1];
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= NewHOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn:= Basis( HomAn );
		ImageList:= [ ];
		for f in BaseHomAn do
			bImage:= NewImageOfBarDifferential( f, n + 1, A, An1, An );
			Add( ImageList, bImage );
		od;
		b:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList );
		return [ GradedHomAn, b, GradedHomAn1 ];
	else
		Print("Put in a correct number, dummy");
	fi;
end;


DebugNewImageOfBarDifferential:= function( f, n, A, An0, An )  #f is a linear map An0 -> A, for An1 the (n-1)-fold tensor product of A
	local j1, j2, i, x, L, BaseA, BaseATuples, ImagesbfList, nOfA, elmt, summand, bfSummand, bf, BaseAn;
	if n > 1 then
		BaseA:= Basis( A );
		BaseATuples:= Tuples( BaseA, n );
		ImagesbfList:= [ ];
		nOfA:= [ ];
		for j1 in [1..(n-1)] do
			Add( nOfA, A );
		od;
		for x in BaseATuples do
			L:= [ x[1] * Image( f, nCustomSimpleTensor( x{[2..n]}, An0, nOfA ) ) ];
			for i in [1..(n-1)] do
				elmt:= Concatenation( x{[1..(i-1)]}, [ x[i] * x[i+1] ], x{[(i+2)..n]} );
				summand:= nCustomSimpleTensor( elmt, An0, nOfA );
				bfSummand:= ((-1)^i ) * Image( f, summand );
				Add( L, bfSummand );
			od;
			Add( L, ((-1)^(n)) * Image( f, nCustomSimpleTensor( x{[1..(n-1)]}, An0, nOfA ) ) * x[n] );
			Add( ImagesbfList, Sum( L ) );
		od;
		BaseAn:= Basis( An );
		bf:= LeftModuleHomomorphismByImages( An, A, BaseAn, ImagesbfList );
		return bf;
	elif n = 1 then 		#In this case, An0 = A and we require that f be an element of A
		ImagesbfList:= [];
		BaseA:= Basis( A );
		for x in BaseA do
			Add( ImagesbfList, x*f - f*x );
		od;
		bf:= LeftModuleHomomorphismByImages( An, A, BaseA, ImagesbfList );
		return bf;
	fi;
end;

DebugNewCoHHomologyMaps2:= function( GradedA, n ) #b_n: Hom( A^{n-1}, A ) -> Hom( A^{n}, A )#
	local f, g, GradedAn0, GradedAn, GradedAn1, A, An0, An, An1, GradedHomAn0, GradedHomAn, GradedHomAn1,
				HomAn0, HomAn, HomAn1, BaseA, BaseHomAn0, BaseHomAn, ImageList1, ImageList2, bImage, bf, b, bn, bn1, b1, b2;
	A:= GradedA[1];
	if n > 1 then
		GradedAn0:= NewTensorProductOfGradedAlgebraNTimes( GradedA, n-1 ); An0:= GradedAn0[1];
		GradedAn:= NewTensorProductOfGradedAlgebras( GradedAn0, GradedA ); An:= GradedAn[1];
		GradedAn1:= NewTensorProductOfGradedAlgebras( GradedAn, GradedA ); An1:= GradedAn1[1];
		GradedHomAn0:= NewHOMGrading( LeftActingDomain( A ), GradedAn0, GradedA ); HomAn0:= GradedHomAn0[1];
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= NewHOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn0:= Basis( HomAn0 );
		BaseHomAn:= Basis( HomAn );
		ImageList1:= [ ]; ImageList2:= [ ];
		for f in BaseHomAn0 do
			bImage:= DebugNewImageOfBarDifferential( f, n, A, An0, An );
			Add( ImageList1, bImage );
		od;
		bn:= LeftModuleHomomorphismByImages( HomAn0, HomAn, BaseHomAn0, ImageList1 );
		for g in BaseHomAn do
			bImage:= DebugNewImageOfBarDifferential( g, n+1, A, An, An1 );
			Add( ImageList2, bImage );
		od;
		bn1:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList2 );
		return [ bn1, bn, GradedHomAn0, GradedHomAn, GradedHomAn1 ];
	elif n = 1 then 					#We consider this a special case, since we use the isomorphism Hom(K, A) = A
		BaseA:= Basis( A );
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedA, GradedA ); HomAn:= GradedHomAn[1];
		BaseHomAn:= Basis( HomAn );
		ImageList1:= [ ];
		for f in BaseA do
			bf:= DebugNewImageOfBarDifferential( f, 1, A, A, A );
			Add( ImageList1, bf );
		od;
		b1:= LeftModuleHomomorphismByImages( A, HomAn, Basis( A ), ImageList1 );
		GradedAn1:= NewTensorProductOfGradedAlgebras( GradedA, GradedA ); An1:= GradedAn1[1];
		GradedHomAn1:= NewHOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		ImageList2:= [];
		for g in BaseHomAn do
			bImage:= DebugNewImageOfBarDifferential( g, 2, A, A, An1 );
			Add( ImageList2, bImage );
		od;
		b2:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList2 );
		return [ b2, b1, GradedA, GradedHomAn, GradedHomAn1 ];
	elif n = 0 then
		BaseA:= Basis( A );
		GradedHomAn:= NewHOMGrading( LeftActingDomain( A ), GradedA, GradedA ); HomAn:= GradedHomAn[1];
		ImageList1:= [ ];
		for f in BaseA do
			bf:= DebugNewImageOfBarDifferential( f, 1, A, A, A );
			Add( ImageList1, bf );
		od;
		b:= LeftModuleHomomorphismByImages( A, HomAn, Basis( A ), ImageList1 );
		return [ b ];
	else
		Print("Enter a nonnegative integer");
	fi;
end;
