
#These first few functions serve as a way to, using the Koszul Calculus papers' notation, to take an Koszul (p+q)-cochain x1...x{p+q} and to
#decompose it into the Koszul p and q-cochains x1...xp and x{p+1}...x{p+q}. Specifically, this is needed for the Koszul cup product [f,g],
#which sends the cochain x1...x{p+q} to (-1)^{p+q}f(x1...xp)g(x{p+1}...x{p+q}).


Decomp1:= function( kQ, x, p )  #Takes in an element x_1...x{p+k} of kQ, and factors on the left into a list of monomials of degree p and a
                                #corresponding list of terms such that the "dot product" of the two lists gives you x_1...x{p+k}
  local xfam, xrep, fakexrep, MonomList, UsedMonomList, y, split, i, a, b, c, Summands, l, List1, List2 ;
  xfam:= FamilyObj( x ); xrep:= ExtRepOfObj( x )[2];
  fakexrep:= ShallowCopy( xrep );
  MonomList:= [];
  for y in fakexrep do
    if IsList( y ) then
      Add( MonomList, y );
    fi;
  od;
  UsedMonomList:= [];
  List1:= []; List2:= [];
  for a in MonomList do
   b:= a{[1..p]};
   if not b in UsedMonomList then
     Add( UsedMonomList, b );
     split:= [ ];
     for c in xrep do
       if IsList(c) and c{[1..p]} = b then
         l:= Length( c );
         Add( split, c{[(p+1)..l]} );
         Add( split, xrep[Position( xrep, c)+1] );
       fi;
     od;
     Add( List1, ObjByExtRep( xfam, [ 0, [ b, One( LeftActingDomain( kQ ) ) ] ] ) );
     Add( List2, ObjByExtRep( xfam, [ 0, split ] ) );
   fi;
  od;
   return [ List1, List2 ];
end;



ScalarMultipleFinder:= function( a, b ) #Given elements a, b of kQ such that b = {\alpha}a, this function outputs \alpha
  local arep, brep, differencerep, a1, alpha ;
  if a = b then
    return 1;
  else
    arep:= ExtRepOfObj( a );
    brep:= ExtRepOfObj( b );
    differencerep:= ExtRepOfObj( b - a );
    a1:= arep[2][2] ;
    alpha:= (differencerep[2][2]/a1) + 1 ;
    return alpha;
  fi;
end;



#ScalarMultipleFinderDebug:= function( a, b ) #Given elements a, b of kQ such that b = {\alpha}a, this function outputs \alpha
#  local arep, brep, differencerep, diff1, pos, a1, alpha ;
#  if a = b then
#    return 1;
#  else
#    arep:= ExtRepOfObj( a );
#    brep:= ExtRepOfObj( b );
#    differencerep:= ExtRepOfObj( b - a );
#    diff1:= differencerep[2][1];
#    pos:= Position( arep[2], diff1 ) ;
#    a1:= arep[2][pos+1] ;
#    alpha:= (differencerep[2][2]/a1) + 1 ;
#    return alpha;
#  fi;
#end;



CoefficientSwapper:= function( kQ, FakeList1, FakeList2, SubspaceList ) #Given the output [FakeList1, FakeList2] of Decomp1, and SubspaceList the
                                                                        #list whose nth entry is the subspace of kQ generated by the nth entry of
                                                                        #FakeList2, this function takes elements of FakeList2 which are scalar
                                                                        #multiples of each other and sends said scalar multiple to the corresponding
                                                                        #element of FakeList1
  local l, UsedList, NewList1, NewList2, i, j, a, b, alpha, arep, brep, Summands, newrep1, newrep2 ;
  l:= Length( FakeList2 );
  NewList1:= [ ] ; NewList2 := [ ] ;
  UsedList:= [ ];
  for i in [1..l] do
    if not SubspaceList[i] in UsedList then
      Add( UsedList, SubspaceList[i] );
      a:= FakeList2[i] ;
      Summands:= [ ];
      for j in [1..l] do
        if SubspaceList[i] = SubspaceList[j] then
          b:= FakeList2[j];
          alpha:= ScalarMultipleFinder( a, b );
          Add( Summands, alpha*FakeList1[j] );
        fi;
      od;
      Add( NewList1, Sum( Summands ) );
      Add( NewList2, a );
    fi;
  od;
  return [ NewList1, NewList2 ];
end;



Decomp2:= function( kQ, FakeList1, FakeList2  ) #Givem kQ and the output [ FakeList1, FakeList2 ] of CoefficientSwapper, this function outputs
                                                #the final decomposition by grouping elements of FakeList1 which have identical corresponding
                                                #elements in FakeList1.
  local UsedMonomList, a, b, c, i, j, List1, List2, l, Summands ;
  UsedMonomList:= [ ];
  List1:= [ ];
  List2:= [ ];
  l:= Length( FakeList2 );
  for i in [1..l] do
    a:= FakeList2[i] ;
    if not a in UsedMonomList then
      Summands:= [ ];
      Add( UsedMonomList, a );
      for j in [1..l] do
        if a = FakeList2[j] then
          Add( Summands, FakeList1[ j ] ) ;
        fi;
      od;
      Add( List1, Sum( Summands ) );
      Add( List2, a );
    fi;
  od;
  return [ List1, List2 ];
end;



Decomp:= function( kQ, x, p ) #Final function which does the desired decomposition.
                              #Problem here, probably
  local L, SubspaceList, a;
  L:= Decomp1( kQ, x, p );
  SubspaceList:= [ ];
  for a in L[2] do
    Add( SubspaceList, Subspace( kQ, [ a ] ) ); #Subspaces are taken to determine which elements are scalar multiples of each other
  od;
  if DuplicateChecker( SubspaceList ) then
    L:= CoefficientSwapper( kQ, L[1], L[2], SubspaceList );
    L:= Decomp2( kQ, L[1], L[2] );
  fi;
  return L;
end;



FinalDecompFunction:= function( kQ, rels, x, p, q, bWpWq ) #x is an element of W_{p+q} = Wpq, WpWq = Wp*Wq
  local Wp, Wq, WpWq, DecompList, C, i, L ;
  C:= Coefficients( bWpWq, x );
#  DecompList:= [ [ ], [ ] ];
  DecompList:= [ ];
  for i in [1..Length(C)] do
    if not C[i] = Zero( LeftActingDomain( kQ ) ) then
      L:= Decomp( kQ, C[i]*bWpWq[i], p );
#      Add( DecompList[1], L[1][1] );
#      Add( DecompList[2], L[2][1] );
      Add( DecompList, [ L[1][1], L[2][1] ] );
    fi;
  od;
  return DecompList;
end;


FinalDecompFunction2:= function( kQ, rels, x, p, q, bWpWq ) #x is an element of W_{p+q} = Wpq, WpWq = Wp*Wq
  local Wp, Wq, WpWq, DecompList, C, i, L ;
  C:= Coefficients( bWpWq, x );
#  DecompList:= [ [ ], [ ] ];
  DecompList:= [ ];
  for i in [1..Length(C)] do
    if not C[i] = Zero( LeftActingDomain( kQ ) ) then
      L:= Decomp( kQ, C[i]*bWpWq[i], p );
#      Add( DecompList[1], L[1][1] );
#      Add( DecompList[2], L[2][1] );
      Add( DecompList, L );
    fi;
  od;
  return DecompList;
end;


####################################################################################################################################################

#This section contains the functions defining the Koszul cup product and Koszul cup bracket on the Koszul complex of a quadratic algebra.

KoszulCupProduct:= function( A, kQ, rels, f, p, g, q )  #This function inputs a Koszul p-chain f and a Koszul q-chain g and outputs their Koszul cup product
                                                        # fcupg: W_{p+q} -> A, as defined in the paper Koszul Calculus (Definition 3.1, p.9). Note that here,
                                                        # due to variable name problems, W_pq = W_{p+q}
  local Wpq, Wp, Wq, WpWq, bWpWq, Apq, Bpq, ImageList, b, L, l, Summands, fcupg ;
  Wpq:= nthKoszulComplexObjectByRels( A, rels, p+q);
  Wp:= nthKoszulComplexObjectByRels( A, rels, p );
  Wq:= nthKoszulComplexObjectByRels( A, rels, q );
  WpWq:= ProductSpace( Wp, Wq );
  bWpWq:= Basis( WpWq );
  Bpq:= Basis( Wpq );
  ImageList:= [ ];
  for b in Bpq do
    Summands:= [];
#    L:= Decomp( kQ, b, p );
    L:= FinalDecompFunction( kQ, rels, b, p, q, bWpWq );
#    for l in [1..Length(L[1])] do
    for l in L do
      Add( Summands, (-1)^(p*q)*Image(f, l[1] )*Image( g, l[2] ) );
    od;
    Add( ImageList, Sum( Summands ) );
  od;
  Apq:= nthGradeOfAlgebra( A, p+q );
  fcupg:= LeftModuleHomomorphismByImages( Wpq, Apq, Bpq, ImageList );
  return fcupg ;
end;



KoszulCupProductDebug:= function( A, kQ, rels, f, p, g, q )  #This function inputs a Koszul p-chain f and a Koszul q-chain g and outputs their Koszul cup product
                                                        # fcupg: W_{p+q} -> A, as defined in the paper Koszul Calculus (Definition 3.1, p.9). Note that here,
                                                        # due to variable name problems, W_pq = W_{p+q}
  local Wpq, Wp, Wq, WpWq, bWpWq, Apq, Bpq, ImageList, b, L, l, Summands, fcupg ;
  Wpq:= nthKoszulComplexObjectByRels( A, rels, p+q);
  Wp:= nthKoszulComplexObjectByRels( A, rels, p );
  Wq:= nthKoszulComplexObjectByRels( A, rels, q );
  WpWq:= ProductSpace( Wp, Wq );
  bWpWq:= Basis( WpWq );
  Bpq:= Basis( Wpq );
  ImageList:= [ ];
  for b in Bpq do
    Summands:= [];
#    L:= Decomp( kQ, b, p );
    L:= FinalDecompFunction( kQ, rels, b, p, q, bWpWq );
#    for l in [1..Length(L[1])] do
    for l in L do
      Add( Summands, (-1)^(p*q)*Image(f, l[1] )*Image( g, l[2] ) );
    od;
    Add( ImageList, Sum( Summands ) );
  od;
  Apq:= nthGradeOfAlgebra( A, p+q );
  fcupg:= LeftModuleHomomorphismByImages( Wpq, Apq, Bpq, ImageList );
  return fcupg ;
end;



KoszulCupBracketCochains:= function( A, kQ, rels, f, p, g, q )  #This function inputs a Koszul p-chain f and a Koszul q-chain g and outputs their Koszul cup bracket
                                                                # [f,g]: W_{p+q} -> A, as defined in the paper Koszul Calculus (Definition 3.1, p.9). Note that here,
                                                                # due to variable name problems, W_pq = W_{p+q}
  local fcupg, gcupf, fg ;
  fcupg:= KoszulCupProduct( A, kQ, rels, f, p, g, q ) ;
  gcupf:= KoszulCupProduct( A, kQ, rels, g, q, f, p ) ;
  fg:= fcupg - (-1)^(p*q)*gcupf;
  return fg;
end;



KoszulCupBracketX:= function( A, kQ, rels, p, q, phi_p, phi_q, phi_pq )  #This function takes an element f of HH^p(A)_0, and element g of
                                                                        #HH^p(A)_0, and the natural homomorphisms phi_p: Hom(W_p, A)_0 -> HH^p(A)_0,
                                                                        #phi_q: Hom(W_q, A)_0 -> HH^p(A)_0, and phi_pq: Hom(W_{p+q}, A)_0 -> HH^{p+q}(A)_0
                                                                        #and outputs the Koszul Cup Bracket as a linear function on the tensor
                                                                        #product HH^p(A)_0 (x) HH^q(A)_0 -> HH^{p+q}(A)_0
  local V, W, VW, HHpq, bVW, b, ImageList, brep, b1, b2, f, g, fg, BracketMap;
  V:= Image( phi_p );
  W:= Image( phi_q );
  VW:= TensorProduct( V, W );   #Note that this function is still experimental, and not found in GAP's documentation
  HHpq:= Image( phi_pq );
  bVW:= Basis( VW );
  ImageList:= [ ];
  for b in bVW do
    brep:= ExtRepOfObj( b );
#    Print( Position( bVW, b ) ) ;
    if not brep[2] = One(LeftActingDomain( kQ ) ) then
      Error( "Weird coefficients for the tensor product basis");
    else
       b1:= brep[1][1];
       b2:= brep[1][2];
       f:= PreImagesRepresentative( phi_p, b1 );
       g:= PreImagesRepresentative( phi_q, b2 );
       fg:= KoszulCupBracketCochains( A, kQ, rels, f, p, g, q );
       Add( ImageList, Image( phi_pq, fg ) );
    fi;
  od;
  BracketMap:= LeftModuleHomomorphismByImages( VW, HHpq, bVW, ImageList );
  return BracketMap ;
end;



KoszulCupBracketSetup1:= function( A, kQ, rels, p, q )
  local L, maps_p, maps_q, maps_pq, phi_p, phi_q, phi_pq ;
  maps_p:= GradedKoszulCohomologyMapsByRels( A, kQ, rels, p, 0 );
  maps_q:= GradedKoszulCohomologyMapsByRels( A, kQ, rels, q, 0 );
  maps_pq:= GradedKoszulCohomologyMapsByRels( A, kQ, rels, p+q, 0 );
  return [ A, kQ, rels, p, q, maps_p, maps_q, maps_pq ];
end;



KoszulCupBracketSetup2:= function( L )
  local phi_p, phi_q, phi_pq ;
  phi_p:= MapsProj( L[6] );
  phi_q:= MapsProj( L[7] );
  phi_pq:= MapsProj( L[8] );
  return [ L[1], L[2], L[3], L[4], L[5], phi_p, phi_q, phi_pq ];
end;



KoszulCupBracket:= function( LL )
  local bra ;
  bra:= KoszulCupBracketX( LL[1], LL[2], LL[3], LL[4], LL[5], LL[6], LL[7], LL[8] );
  return bra ;
end;


####################################################################################################################################################



EulerDerivation:= function( A, kQ, rels ) #Here, A = kQ/rels, for rels some set of relations. This function outputs the so-called
                                    #Euler derivation e_A of A, as defined in the paper Koszul Calculus (Definition 3.6, p.10)
  local kQ1, Agens, e_A ;
  Agens:= NonOneGeneratorsOfAlgebra( A );
  kQ1:= nthKoszulComplexObjectByRels( A, rels, 1 );
  e_A:= LeftModuleHomomorphismByImages( kQ1, A, Basis( kQ1 ), Agens );
  return e_A ;
end;


####################################################################################################################################################


LinearSurjectionSection:= function( phi )
  local V, W, bW, b, ImageList, psi ;
  V:= Source( phi );
  W:= Range( phi );
  bW:= Basis( W );
  ImageList:= [ ];
  for b in bW do
    Add( ImageList, PreImagesRepresentative( phi, b ) );
  od;
  psi:= LeftModuleHomomorphismByImages( W, V, bW, ImageList );
  return psi;
end;






####################################################################################################################################################

#An attempt to implement the comultiplication on the free algebra k<x1,...,xn> in GAP


#MonomialComultiplication:= function( kQ, x )  #This function computes the image of the monomial x of kQ under the comultiplication map
#  local xrep, xfam, j, k, ImageList, x0, x1, x2 ;
#  xfam:= FamilyObj( x );
#  xrep:= ExtRepOfObj( x )[2];
#  k:= Length( xrep[1] ) ;
#  ImageList:= [ ];
#  Add( ImageList, xrep[2] );
#  x0:= ObjByExtRep( xfam, [ 0, [ xrep[1], One( LeftActingDomain( kQ ) ) ] ] );
#  Add( ImageList, [ One( kQ ), x0 ] );
#  for j in [1..(k-1)] do
#    x1:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[1..j]}, One( LeftActingDomain( kQ ) ) ] ] );
#    x2:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[(j+1)..k]}, One( LeftActingDomain( kQ ) ) ] ] );
#    Add( ImageList, [ x1, x2 ] );
#  od;
#  Add( ImageList, [ x0, One( kQ ) ] );
#  return ImageList ;
#end;



#MonomialComultiplication:= function( kQ, x )  #This function computes the image of the monomial x of kQ under the comultiplication map
#  local xrep, xfam, j, k, ImageList, x0, x1, x2 ;
#  xfam:= FamilyObj( x );
#  xrep:= ExtRepOfObj( x )[2];
#  k:= Length( xrep[1] ) ;
#  ImageList:= [ ];
#  Add( ImageList, [ One( kQ ), x ] );
#  for j in [1..(k-1)] do
#    if j < (k+1)/2 or j = (k+1)/2 then
#      x1:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[1..j]}, One( LeftActingDomain( kQ ) ) ] ] );
#      x2:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[(j+1)..k]}, xrep[2] ] ] );
#      Add( ImageList, [ x1, x2 ] );
#    else
#      x1:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[1..j]}, xrep[2] ] ] );
#      x2:= ObjByExtRep( xfam, [ 0, [ xrep[1]{[(j+1)..k]}, One( LeftActingDomain( kQ ) ) ] ] );
#      Add( ImageList, [ x1, x2 ] );
#    fi;
#  od;
#  Add( ImageList, [ x, One( kQ ) ] );
#  return ImageList ;
#end;



#ComultiplicationLong:= function( kQ, x )
#  local xrep, xfam, l, i, ImageList, x_i ;
#  xfam:= FamilyObj( x );
#  xrep:= ExtRepOfObj( x )[2];
#  l:= Length( xrep )/2;
#  ImageList:= [ ];
#  for i in [1..l] do
#    x_i:= ObjByExtRep( xfam, [ 0, [ xrep[(2*i)-1], xrep[2*i] ] ] );
#    Add( ImageList, MonomialComultiplication( kQ, x_i ) );
#  od;
#  return ImageList;
#end;



#TensorTestForComult:= function( kQ, rels, L, p, q ) #L needs to be the output of ComultiplicationLong( kQ, x ), where x is composed entire of
                                                    #terms of degree p+q.
#  local Wp, Wq, WpxWq, LLength, TensorList, tensorfam, l ;
#  LLength:= Length( L[1] );
#  Wp:= nthKoszulComplexObjectByRels2( kQ, rels, p );
#  Wq:= nthKoszulComplexObjectByRels2( kQ, rels, q );
#  WpxWq:= TensorProduct( Wp, Wq );
#  tensorfam:= FamilyObj( Basis( WpxWq )[1] );
#  TensorList:= [ ];
#  for l in L do
#    Add( TensorList, ObjByExtRep( tensorfam, [ [ l[p+2][1], l[p+2][2] ], l[1] ] ) );
#  od;
#  return [ Sum( TensorList ), WpxWq ];
#end;



#ComultiplicationColumnSimplifierX:= function( kQ, Column, Orientation ) #Orientation is either "Left" or "Right"
#  local SimplifiedColumn, SummandList, Elmt, IntermediateList, ColTerms, FactoringTerms, UsedTerms, l, a ;
#  SimplifiedColumn:= [ ];
#  UsedTerms:= [ ];
#  FactoringTerms:= [ ];
#  if Orientation = "Left" then
#    for l in Column do
#      Add( FactoringTerms, l[1] );
#    od;
#    for l in Column do
#      if not l[1] in UsedTerms then
#        Add( UsedTerms, l[1] );
#        SummandList:= [ ];
#        for a in Column do
#          if a[1] = l[1] then
#            Add( SummandList, a[2] );
#          fi;
#        od;
#        Elmt:= Sum( SummandList );
#        Add( SimplifiedColumn, [ l[1], Elmt ] );
#      fi;
#    od;
#  elif Orientation = "Right" then
#    SimplifiedColumn:= ["whoops"] ;
#  fi;
#  return SimplifiedColumn ;
#end;



#ComultiplicationColumnSimplifier:= function( kQ, L, i )
#  local LLength, Col, l, SimplifiedCol ;
#  LLength:= Length( L[1] );
#  i:= i+1;
#  Col:= [ ];
#  if i < (2+LLength)/2 or i = (2+LLength)/2 then
#    for l in L do
#      Add( Col, [ l[i][1], l[1]*l[i][2] ] );
#    od;
#    SimplifiedCol:= ComultiplicationColumnSimplifierX( kQ, Col, "Left" );
#  else
#    for l in L do
#      Add( Col, [ l[1]*l[i][1], l[i][2] ] );
#    od;
#    SimplifiedCol:= ComultiplicationColumnSimplifierX( kQ, Col, "Right" );
#  fi;
#  return SimplifiedCol ;
#end;
