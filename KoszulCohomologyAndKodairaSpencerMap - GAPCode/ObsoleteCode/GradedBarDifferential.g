
#ProfileFunctions( [ ImageOfBarDifferential, BarDifferential, TensorProductOfGradedAlgebras, HOMGrading ] );

#ProfileGlobalFunctions( true );

LoadPackage("qpa");


#################################################################################################################################################################################


GoodListDisplay:= function( L )
	local x;
	for x in L do
		Print( x, "\n" );
	od;
end;


#################################################################################################################################################################################


FreeKAlgebra:= function(K, n, indeterminate) 		#Constructs the free K-algebra on n generators as the path algbra of the n-rose
	local i, L, Arrow, nRose, KQ, variablename, identity;
	L:= [ ];
	identity:= StringFormatted( "1{}", indeterminate );
	if n = 0 then
		nRose:= Quiver( [ identity ], [ ] );
		KQ:= PathAlgebra( K, nRose );
		AssignGeneratorVariables( KQ );
		return KQ ;
	else
		for i in [1..n] do
			Arrow:= [ identity, identity ];
			variablename:= StringFormatted( "{}{}", indeterminate, i );
			Add( Arrow, variablename );
			Add( L, Arrow );
		od;
		nRose:= Quiver( [ identity ], L );
		KQ:= PathAlgebra( K, nRose );
		AssignGeneratorVariables( KQ );
		return KQ ;
	fi;
end;


GBQuotient:= function(kQ, rels)
	local gb, grb, I, A ;
	gb:= GBNPGroebnerBasis( rels, kQ );
	I:= Ideal( kQ, gb );
	GroebnerBasis( I, gb );
	A:= kQ/I;
	return A;
end;


QuadraticDualByRels:= function(KQ, Rels)		#Rels is a set of quadratic relations in the path algebra KQ. This fuction outputs the quadratic dual of KQ/(Rels)
	local gb, grb, PerpRels, kq, I, Aschrick ;
	PerpRels:= QuadraticPerpOfPathAlgebraIdeal( Rels );
	kq:= PerpRels[1];
	I:= Ideal( kq, PerpRels[2] );
	gb:= GroebnerBasisFunction( kq )( PerpRels[2], kq );
	grb:= GroebnerBasis( I, gb );
	Aschrick:= kq/I;
	AssignGeneratorVariables( Aschrick );
	return Aschrick;
end;

QuadraticDual:= function( A )		#Rels is a set of quadratic relations in the path algebra KQ. This fuction outputs the quadratic dual of KQ/(Rels)
	local KQ, Rels, gb, grb, PerpRels, kq, I, Aschrick ;
	KQ:= OriginalPathAlgebra( A );
	Rels:= RelationsOfAlgebra( A );
	PerpRels:= QuadraticPerpOfPathAlgebraIdeal( Rels );
	kq:= PerpRels[1];
	I:= Ideal( kq, PerpRels[2] );
	gb:= GroebnerBasisFunction( kq )( PerpRels[2], kq );
	grb:= GroebnerBasis( I, gb );
	Aschrick:= kq/I;
	AssignGeneratorVariables( Aschrick );
	return [ Aschrick, kq, I, PerpRels[2] ];
end;


NonOneGeneratorsOfAlgebra:= function( A )
	local Gens, NonOneGens, x ;
	Gens:= GeneratorsOfAlgebra( A );
	NonOneGens:= [ ];
	for x in Gens do
		if not x = One( A ) then
			Add( NonOneGens, x );
		fi;
	od;
	return NonOneGens ;
end;


IsTrue:= function( obj )
	if obj = true then
		return true;
	else
		return false;
	fi;
end;



#################################################################################################################################################################################


GradedBaseField:= function( K )
	return [ K, [ [ K, 0  ] ] ];
end;


GeneratorsOfNthGradedIdeal:= function( kQ, rels, n )			#This function outputs a set of generators for the subspace I \cap kQn of kQ, for a set rels of homogeneous generators of I#
	local L, i, MonomialsOfLesserDegree, V, iter, nGens, P ;
	if n = 0 then
		V:= Subspace( kQ, [ One( kQ ) ], "basis" );
	else
		V:= Subspace( kQ, NthPowerOfArrowIdeal( kQ, n ), "basis" );
	fi;
	L:= [ [ One( kQ ) ] ];
	nGens:= [ ];
	for i in [1..n] do
		Add( L, NthPowerOfArrowIdeal( kQ, i ) );
	od;
	MonomialsOfLesserDegree:= Union( L );
	iter:= IteratorOfCartesianProduct( MonomialsOfLesserDegree, rels, MonomialsOfLesserDegree );
	for P in iter do
		if P[1]*P[2]*P[3] in V then								#checks if the product is homogeneous of degree n
			Add( nGens, P[1]*P[2]*P[3] );
		else
			continue ;
		fi;
	od;
	return nGens ;
end;


OrderedPathsOfLengthN:= function( kQ, n )
	local x, i, y, L, LList, Gens, VariableName, Cart, degreeN;
	if n = 0 then
		return [ One( kQ ) ];
	else
		L:= [ ];
		Gens:= GeneratorsOfAlgebra( kQ );
		VariableName:= Length( GeneratorsOfAlgebra( kQ ) );
		for x in Gens do
			if not x = One( kQ ) then
				Add( L, x );
			fi;
		od;
		LList:= [];
		for i in [1..n] do
			Add( LList, L );
		od;
		#Cart:= Tuples( L, n );
		Cart:= Cartesian( LList );
		degreeN:= [];
		for y in Cart do
			if not Product( y ) in degreeN and not Product( y ) = Zero( kQ ) then
				Add( degreeN, Product( y ) );
			fi;
		od;
		return degreeN ;
	fi;
end;


nthGradeOfAlgebra:= function( A, n )
	local gens, Grade;
	gens:= OrderedPathsOfLengthN( A, n );
	Grade:= Subspace( A, gens );
	return Grade ;
end;



GradingOfAlgebra:= function( A )    #This function assumes that the ideal generated by rels intersects kQ_0 trivially and that rels is a set of homogeneous relations of kQ
	local Counter, I, kQ, rels, DimTotal, ComponentList, DimOfComponents, gens, Grade ;
	if IsFiniteDimensional( A ) = true then
		DimTotal:= Dimension( A );
		ComponentList:= [ ];
		DimOfComponents:= [ ];
		Counter:= 0 ;
		while Sum( DimOfComponents ) < DimTotal do
			Grade:= nthGradeOfAlgebra( A, Counter );
			Add( ComponentList, [ Grade, Counter ] );
			Add( DimOfComponents, Dimension( Grade ) );
			Counter:= Counter + 1;
		od;
		if Sum( DimOfComponents ) = DimTotal then
			return [ A, ComponentList ] ;
		else
			return [ A, ComponentList, "The relations may not be homogeneous" ];
		fi;
	else
		Print("The algebra is not finite dimensional");
	fi;
end;


GradedPositionFinder:= function(GradedA, n)
	local x, ListA, L;
	L:= [ ];
	ListA:= GradedA[2];
	for x in ListA do
		if x[2] = n then
			Add( L, x[1] );
		else
			continue;
		fi;
	od;
	if L = [ ] then
		return TrivialSubspace( GradedA[1] );
	else
		return L[1];
	fi;
end;


GradedDimensionVerifier:= function( GradedA )
	local x, A, ListA, ListOfDims;
	A:= GradedA[1]; ListA:= GradedA[2];
	ListOfDims:= [ ];
	for x in ListA do
		Add( ListOfDims, Dimension( x[1] ) ) ;
	od;
	return [ Dimension( A ), Sum( ListOfDims ) ];
end;


GradedConditionVerifier:= function( GradedA )
	local ListA, cart, x, L, ProdSpace;
	ListA:= GradedA[2] ;
	cart:= IteratorOfCartesianProduct( ListA, ListA );
	L:= [];
	for x in cart do
		ProdSpace:= ProductSpace( x[1][1], x[2][1] );
		if not ProdSpace = GradedPositionFinder( GradedA, x[1][2] + x[2][2] ) then
			Add( L, x );
		fi;
#		Add( L, ProductSpace( x[1][1], x[2][1] ) = GradedPositionFinder( GradedA, x[1][2] + x[2][2] ) );
	od;
#	return ForAll( L, IsTrue );
	return L ;
end;

GradedSubset:= function( GradedA, SubsetOfA )
	local A, GradedSubset, GradedPart, x ;
	A:= GradedA[1];
	GradedSubset:= [ SubsetOfA ];
	GradedPart:= [ ];
	for x in GradedA[2] do
		Add( GradedPart, [ Intersection( x[1], SubsetOfA ), x[2] ] ) ;
	od;
	Add( GradedSubset, GradedPart );
	return GradedSubset ;
end;


BasisForGradedAlgebra:= function( GradedA )
	local A, L, x, NewBase;
	A:= GradedA[1];
	L:= [];
	for x in GradedA[2] do
		Add( L, Basis( x[1] ) );
	od;
	NewBase:= Basis( A, Union( L ) );
	return NewBase;
end;


#################################################################################################################################################################################


SubspacesToTensorProduct:= function( AB, Ai, Bj, A, B ) #Takes subspaces Ai of A and Bj of B and returns the subspace Ai \otimes Bj of AB = A \otimes B
	local BasisAi, BasisBj, TensorBasis, iter, P, s, TensorSubspace ;
	BasisAi:= Basis( Ai );
	BasisBj:= Basis( Bj );
	TensorBasis:= [ ];
	iter:= IteratorOfCartesianProduct( BasisAi, BasisBj );
	for P in iter do
		s:= CustomSimpleTensor( [ P[1], P[2] ], AB, A, B );
		Add( TensorBasis, s );
	od;
	TensorSubspace:= Subspace( AB, TensorBasis );
	return TensorSubspace ;
end;


nthGradeTensorProduct:= function( AB, GradedA, GradedB, n )
	local A, B, ListA, ListB, iter, x, GradedPart, nthGradeList, nthGrade ;
	nthGradeList:= [ ];
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	iter:= IteratorOfCartesianProduct( ListA, ListB );
	for x in iter do
		if x[1][2] + x[2][2] = n then
			GradedPart:= SubspacesToTensorProduct( AB, x[1][1], x[2][1], A, B );
			Add( nthGradeList, GradedPart );
		else
			continue;
		fi;
	od;
	nthGrade:= Sum( nthGradeList );
	return nthGrade;
end;


TensorProductOfGradedAlgebras:= function( GradedA, GradedB ) #AB is the tensor product of A and B, GradedA is a list [ A, L ], where L is the list outputted by NewGradingOfAlgebraByRels( kQ, rels )
	local A, B, AB, DimAB, ListA, ListB, GradesA, GradesB, x1, x2, x3, x4, iter, cart, IndexList, ABmin, ABmax, ABGrades, nthGrade ;
	A:= GradedA[1]; B:= GradedB[1];
	AB:= AlgebraTensorProduct( A, B );
	DimAB:= Dimension( AB );
	ListA:= GradedA[2]; GradesA:= [ ];
	ListB:= GradedB[2]; GradesB:= [ ];
	for x1 in ListA do
		Add( GradesA, x1[2] );
	od;
	for x2 in ListB do
		Add( GradesB, x2[2] );
	od;
	cart:= IteratorOfCartesianProduct( GradesA, GradesB );
	IndexList:= [ ];
	for x3 in cart do
		Add( IndexList, Sum( x3 ) );
	od;
	ABmin:= Minimum( IndexList );
	ABmax:= Maximum( IndexList );
	ABGrades:= [ ];
	for x4 in [ABmin..ABmax] do
		nthGrade:= nthGradeTensorProduct( AB, GradedA, GradedB, x4 );
		Add( ABGrades, [ nthGrade, x4 ] );
	od;
	return [ AB, ABGrades ];
end;


TensorProductOfGradedAlgebraNTimes:= function( GradedA, n) 	#GradedA is a list of the form [ A, L ], where L is the grading of A.
	local TProduct, LesserTensorProduct, LLesser, K;
	if n = -1 then
		K:= TrivialSubalgebra( GradedA[1] );
		return [ K, [ [ K, 0 ] ] ];
	elif n = 0 then
		K:= LeftActingDomain( GradedA[1] );
		return [ K, [ [ K, 0 ] ] ];
	elif n = 1 then
		return GradedA ;
	elif n = 2 then
		TProduct:= TensorProductOfGradedAlgebras( GradedA, GradedA );
		return TProduct;
	elif n > 2 then
		TProduct:= TensorProductOfGradedAlgebras( TensorProductOfGradedAlgebraNTimes( GradedA, n-1 ), GradedA );
		return TProduct ;
	else
		Print("what are you doing");
	fi;
end;


#################################################################################################################################################################################


IsMapOfDegreeN:= function( f, GradedA, GradedB, n )
	local A, B, ListA, ListB, NewListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, c, x1, x2, x3, x4, x5, x6, i, MaxCounter, MinCounter, ImageList, L, TruthList, t ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
#
	IndexA:= [ ]; IndexB:= [ ];
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	MaxCounter:= Bmax + 1; MinCounter:= Bmin - 1;
	NewListB:= ShallowCopy( ListB );
	c:= Length( ListA ) + AbsInt(n)*2;
	for x3 in [1..c] do												#Need to add a considerable amount of trivial graded parts to B to make the function verify degree well
		Add( NewListB, [ TrivialSubspace( B ), MaxCounter ] );
		Add( NewListB, [ TrivialSubspace( B ), MinCounter ] );
		MaxCounter:= MaxCounter + 1; MinCounter:= MinCounter - 1;
	od;
#
	ImageList:= [ ];
	for i in [Amin..Amax] do										#This part makes pairs [ B_{i+n}, f(Ai) ], for graded parts Bj and Ai of B and A, respectively, so that
		L:= [ ];																	#we may use IsSubset afterwards on this list.
		for x4 in NewListB do
			if x4[2] = n + i then
				Add( L, x4[1] );
			else
				continue;
			fi;
		od;
		for x5 in ListA do
			if x5[2] = i then
				Add( L, Image( f, x5[1] ) );
			else
				continue;
			fi;
		od;
		Add( ImageList, L );
	od;
#
	TruthList:= [ ];												#This part is needed since the ForAll function only works on unary functions
	for x6 in ImageList do
		Add( TruthList, IsSubset( x6[1], x6[2] ) );
	od;
	t:= ForAll( TruthList, IsTrue );
return t;
end;


#################################################################################################################################################################################


HomSpaceBasisByTuples:= function( A, B, BaseA, BaseB )  #Returns a basis for the subspace Hom(Ai, Bj) of Hom(A, B), without explicitly computing the subspace
	local x1, i, cart, L, f, HomBase ;
	cart:= IteratorOfCartesianProduct( BaseA, BaseB );
	HomBase:= [ ];
	for x1 in cart do
		i:= Position( BaseA, x1[1] );
		L:= [];
		CopyListEntries( [ Zero( B ) ], 1, 0, L, 1, 1, Length( BaseA ) );    #This is to define the map sending the basis element x1[1] to x1[2], and all
		L[i]:= x1[2];																															#other basis elements to 0
		f:= LeftModuleHomomorphismByImages( A, B, BaseA, L );
		Add( HomBase, f );
	od;
	return HomBase;
end;


HomSpaceBasis:= function( GradedA, GradedB, Ai, Bj)  #Returns a basis for the subspace Hom(Ai, Bj) of Hom(A, B), without explicitly computing the subspace
	local x1, i, A, B, bA, bAi, bBj, cart, L, f, HomBase ;
	A:= GradedA[1]; B:= GradedB[1];
#	bA:= BasisForGradedAlgebra( GradedA );
 	bA:= Basis( A );
	bAi:= Basis( Ai );																					#We have as an assumption that Basis( Ai ) is a subset of Basis( A )
	bBj:= Basis( Bj );
	cart:= Cartesian( bAi, bBj );
	HomBase:= [ ];
	for x1 in cart do
		i:= Position( bA, x1[1] );
		L:= [];
		CopyListEntries( [ Zero( B ) ], 1, 0, L, 1, 1, Length( Basis( A ) ) );    #This is to define the map sending the basis element x1[1] to x1[2], and all
		L[i]:= x1[2];																															#other basis elements to 0
		f:= LeftModuleHomomorphismByImages( A, B, bA, L );
		Add( HomBase, f );
	od;
	return HomBase;
end;


nthGradedHom:= function( K, HomAB, GradedA, GradedB, n )   #This function outputs the nth graded Hom set Hom( A, B )_n of linear maps A -> B of degree n
	local i, x1, f, A, B, ListA, ListB, BaseHomAB, nListB, RestrictedSubspaceGens, HomSubspace, SummandList;
	A:= GradedA[1]; ListA:= GradedA[2]; BaseHomAB:= Basis( HomAB );
	B:= GradedB[1]; ListB:= GradedB[2];
	nListB:= [ ];
	for x1 in ListA do
		Add( nListB, GradedPositionFinder( GradedB, n + x1[2] ) );
	od;
	SummandList:= [ ];
	for i in [1..Length( ListA )] do
		RestrictedSubspaceGens:= HomSpaceBasis( GradedA, GradedB, ListA[i][1], nListB[i] );
		HomSubspace:= Subspace( HomAB, RestrictedSubspaceGens );
		Add( SummandList, HomSubspace );
	od;
	return Sum( SummandList );
end;



HOMGrading:= function( K, GradedA, GradedB ) #This function returns the grading of HOM(A, B) = \bigoplus_{n \in \mathbb{Z}} Hom(A, B)_n
	local n, x1, x2, x3, x4, x5, A, B, HomAB, ListA, ListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, MaxCounter, MinCounter, HOMMax, HOMMin, HomGrades, nGrade ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	HomAB:= Hom( K, A, B );
	IndexA:= [ ]; IndexB:= [ ];
#
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	HOMMax:= Bmax - Amin; HOMMin:= Bmin - Amax;
	HomGrades:= [ ];
	for n in [HOMMin..HOMMax] do
		nGrade:= nthGradedHom( K, HomAB, GradedA, GradedB, n );
		Add( HomGrades, [ nGrade, n ] );
	od;
	return [ HomAB, HomGrades ];
end;


#################################################################################################################################################################################

#An0 = A^{\otimes (n-1)}, An = A^{\otimes n}, HomAn0 = Hom(A^{\otimes (n-1)}, A), HomAn = Hom(A^{\otimes n}, A)


ImageOfBarDifferential:= function( f, n, A, An0, An )  #f is a linear map An0 -> A, for An1 the (n-1)-fold tensor product of A
	local j1, j2, i, x, y, L, BaseA, BaseATuples, ImagesbfList, n0OfA, nOfA, elmt, summand, bfSummand, bf, FakeBaseAn, BaseAn;
	BaseA:= Basis( A );
	BaseATuples:= Tuples( BaseA, n );
	ImagesbfList:= [ ];
	n0OfA:= [ ]; nOfA:= [ ];
	for j1 in [1..n] do
		if j1 < n then
			Add( n0OfA, A );
			Add( nOfA, A );
		elif j1 = n then
			Add( nOfA, A );
		fi;
	od;
	for x in BaseATuples do					#We are here simply following the formula for image bf of g under the bar differential b
		L:= [ x[1] * Image( f, nCustomSimpleTensor( x{[2..n]}, An0, n0OfA ) ) ];
		for i in [1..(n-1)] do
			if x[i]*x[i+1] = Zero(A) then
				bfSummand:= Zero(A);
			else
				elmt:= Concatenation( x{[1..(i-1)]}, [ x[i] * x[i+1] ], x{[(i+2)..n]} );
				summand:= nCustomSimpleTensor( elmt, An0, n0OfA );
				bfSummand:= ((-1)^i ) * Image( f, summand );
			fi;
			Add( L, bfSummand );
		od;
		Add( L, ((-1)^(n)) * Image( f, nCustomSimpleTensor( x{[1..(n-1)]}, An0, n0OfA ) ) * x[n] );
		Add( ImagesbfList, Sum( L ) );
	od;
	FakeBaseAn:= [];
	for y in BaseATuples do
		Add( FakeBaseAn, nCustomSimpleTensor( y, An, nOfA ) );
	od;
	BaseAn:= Basis( An, FakeBaseAn );
	bf:= LeftModuleHomomorphismByImages( An, A, BaseAn, ImagesbfList );
	return bf;
end;


BarDifferential:= function( A, An0, An, HomAn0, HomAn, n ) #returns the linear map b_n: Hom(A^{\otimes n-1}, A) -> Hom(A^{\otimes n}, A)
	local  BaseHomAn0, bImage, ImageList, f, b;
	BaseHomAn0:= Basis( HomAn0 );
	ImageList:= [ ];
	for f in BaseHomAn0 do
		bImage:= ImageOfBarDifferential( f, n, A, An0, An );
		Add( ImageList, bImage );
	od;
		b:= LeftModuleHomomorphismByImages( HomAn0, HomAn, BaseHomAn0, ImageList );
	return b;
end;
#The above is another source of ForAll calls

#GradedCoHHomologyMaps:= function( GradedA, n, i ) #b_n: Hom( A^{n-1}, A ) -> Hom( A^{n}, A )#
#	local A, GradedAn0,GradedAn, GradedAn1, GradedHomAn0, GradedHomAn, GradedHomAn1,
#	 HomAn0i, HomAni, HomAn1i, bni, bn1i;
#	A:= GradedA[1];
#	GradedAn0:= TensorProductOfGradedAlgebraNTimes( GradedA, n-1 );
#	GradedAn:= TensorProductOfGradedAlgebras( GradedAn0, GradedA );
#	GradedAn1:= TensorProductOfGradedAlgebras( GradedAn, GradedA );
#	GradedHomAn0:= HOMGrading( LeftActingDomain( A ), GradedAn0, GradedA );
#	HomAn0i:= GradedPositionFinder( GradedHomAn0, i );
#	GradedHomAn:= HOMGrading( LeftActingDomain( A ), GradedAn, GradedA );
#	HomAni:= GradedPositionFinder( GradedHomAn, i );
#	GradedHomAn1:= HOMGrading( LeftActingDomain( A ), GradedAn1, GradedA );
#	HomAn1i:= GradedPositionFinder( GradedHomAn1, i );
#	bni:= BarDifferential( A, GradedAn0[1], GradedAn[1], HomAn0i, HomAni, n );
#	bn1i:= BarDifferential( A, GradedAn[1], GradedAn1[1], HomAni, HomAn1i, n+1 );
#	return [ bn1i, bni ];
#end;


#GradedCoHHomologyMaps:= function( GradedA, n, i ) #Computes the maps necessary to compute the nth Hochschild Cohomology of the graded algebra A
#	local A, GradedAn0,GradedAn, GradedAn1, GradedHomAn0, GradedHomAn, GradedHomAn1,
#	 HomAn0, HomAn, HomAn1, HomAn0i, HomAni, HomAn1i, bni, bn1i;
#	A:= GradedA[1];
#	if n = 0 then
#		GradedAn:= TensorProductOfGradedAlgebraNTimes( GradedA, 0 );
#		GradedAn1:= TensorProductOfGradedAlgebraNTimes( GradedA, 1 );
#		if i = "full" then
#			HomAni:= Hom( LeftActingDomain( A ), GradedAn[1], A );
#			HomAn1i:= Hom( LeftActingDomain( A ), GradedAn1[1], A );
#		elif IsInt( i ) = true then
#			GradedHomAn:= HOMGrading( LeftActingDomain( A ), GradedAn, GradedA );
#			GradedHomAn1:= HOMGrading( LeftActingDomain( A ), GradedAn1, GradedA );
#			HomAni:= GradedPositionFinder( GradedHomAn, i );
#			HomAn1i:= GradedPositionFinder( GradedHomAn1, i );
#		else
#			Print( "Enter an integer or the string 'full' as final argument" );
#		fi;
#		bn1i:= BarDifferential( A, GradedAn[1], GradedAn1[1], HomAni, HomAn1i, n+1 );
#		return bn1i ;
#	elif n > 0 then
#		GradedAn0:= TensorProductOfGradedAlgebraNTimes( GradedA, n-1 );
#		GradedAn:= TensorProductOfGradedAlgebras( GradedAn0, GradedA );
#		GradedAn1:= TensorProductOfGradedAlgebras( GradedAn, GradedA );
#		if i = "full" then
#			HomAn0i:= Hom( LeftActingDomain( A ), GradedAn0[1], A );
#			HomAni:= Hom( LeftActingDomain( A ), GradedAn[1], A );
#			HomAn1i:= Hom( LeftActingDomain( A ), GradedAn1[1], A );
#		elif IsInt( i ) = true then
#			GradedHomAn0:= HOMGrading( LeftActingDomain( A ), GradedAn0, GradedA );
#			GradedHomAn:= HOMGrading( LeftActingDomain( A ), GradedAn, GradedA );
#			GradedHomAn1:= HOMGrading( LeftActingDomain( A ), GradedAn1, GradedA );
#			HomAn0i:= GradedPositionFinder( GradedHomAn0, i );
#			HomAni:= GradedPositionFinder( GradedHomAn, i );
#			HomAn1i:= GradedPositionFinder( GradedHomAn1, i );
#		else
#			Print("Enter an integer or the string 'full' as final argument");
#		fi;
#		bni:= BarDifferential( A, GradedAn0[1], GradedAn[1], HomAn0i, HomAni, n );
#		bn1i:= BarDifferential( A, GradedAn[1], GradedAn1[1], HomAni, HomAn1i, n+1 );
#		return [ bn1i, bni ];
#	fi;
#end;

GradedCoHHomologyMaps:= function( GradedA, n, i ) #Computes the maps necessary to compute the nth Hochschild Cohomology of the graded algebra A
	local A, GradedAn0,GradedAn, GradedAn1, GradedHomAn0, GradedHomAn, GradedHomAn1,
	 HomAn0, HomAn, HomAn1, HomAn0i, HomAni, HomAn1i, bni, bn1i;
	A:= GradedA[1];
	if n = 0 then
		GradedAn:= TensorProductOfGradedAlgebraNTimes( GradedA, 0 );
		GradedAn1:= TensorProductOfGradedAlgebraNTimes( GradedA, 1 );
		HomAn:= Hom( LeftActingDomain( A ), GradedAn[1], A );
		HomAn1:= Hom( LeftActingDomain( A ), GradedAn1[1], A );
		if i = "full" then
			HomAni:= HomAn;
			HomAn1i:= HomAn1;
		elif IsInt( i ) = true then
			HomAni:= nthGradedHom( LeftActingDomain( A ), HomAn, GradedAn, GradedA, i );
			HomAn1i:= nthGradedHom( LeftActingDomain( A ), HomAn1, GradedAn1, GradedA, i );
		else
			Print( "Enter an integer or the string 'full' as final argument" );
		fi;
		bn1i:= BarDifferential( A, GradedAn[1], GradedAn1[1], HomAni, HomAn1i, n+1 );
		return bn1i ;
	elif n > 0 then
		GradedAn0:= TensorProductOfGradedAlgebraNTimes( GradedA, n-1 );
		GradedAn:= TensorProductOfGradedAlgebras( GradedAn0, GradedA );
		GradedAn1:= TensorProductOfGradedAlgebras( GradedAn, GradedA );
		HomAn0:= Hom( LeftActingDomain( A ), GradedAn0[1], A );
		HomAn:= Hom( LeftActingDomain( A ), GradedAn[1], A );
		HomAn1:= Hom( LeftActingDomain( A ), GradedAn1[1], A );
		if i = "full" then
			 HomAn0i:= HomAn0;
			 HomAni:= HomAn;
			 HomAn1i:= HomAn1;
		elif IsInt( i ) = true then
			HomAn0i:= nthGradedHom( LeftActingDomain( A ), HomAn0, GradedAn0, GradedA, i );
			HomAni:= nthGradedHom( LeftActingDomain( A ), HomAn, GradedAn, GradedA, i );
			HomAn1i:= nthGradedHom( LeftActingDomain( A ), HomAn1, GradedAn1, GradedA, i );
		else
			Print("Enter an integer or the string 'full' as final argument");
		fi;
		bni:= BarDifferential( A, GradedAn0[1], GradedAn[1], HomAn0i, HomAni, n );		#replaced HomAni with HomAn
		bn1i:= BarDifferential( A, GradedAn[1], GradedAn1[1], HomAni, HomAn1i, n+1 );
		return [ bn1i, bni ];
	fi;
end;

GradedCoHHomology:= function( GradedA, n, i )
	local maps;
	maps:= GradedCoHHomologyMaps( GradedA, n, i );
	if n = 0 then
		return Kernel( maps );
	elif n > 0 then
		return Kernel( maps[1] )/Image( maps[2] );
	else
		Print( "Verify your inputs");
	fi;
end;
