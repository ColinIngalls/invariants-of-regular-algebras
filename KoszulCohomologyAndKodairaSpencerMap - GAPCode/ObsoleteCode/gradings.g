

#The following code always assumes that the ideal generated by the set of relations rels is *not* all of kQ

Read("HochschildCohomology.g");



GeneratorsOfNthGradedIdeal:= function( kQ, rels, n )			#This function outputs a set of generators for the subspace I \cap kQn of kQ, for a set rels of homogeneous generators of I#
	local L, i, MonomialsOfLesserDegree, V, iter, nGens, P ;
	if n = 0 then
		V:= Subspace( kQ, [ One( kQ ) ], "basis" );
	else
		V:= Subspace( kQ, NthPowerOfArrowIdeal( kQ, n ), "basis" );
	fi;
	L:= [ [ One( kQ ) ] ];
	nGens:= [ ];
	for i in [1..n] do
		Add( L, NthPowerOfArrowIdeal( kQ, i ) );
	od;
	MonomialsOfLesserDegree:= Union( L );
	iter:= IteratorOfCartesianProduct( MonomialsOfLesserDegree, rels, MonomialsOfLesserDegree );
	for P in iter do
		if P[1]*P[2]*P[3] in V then								#checks if the product is homogeneous of degree n
			Add( nGens, P[1]*P[2]*P[3] );
		else
			continue ;
		fi;
	od;
	return nGens ;
end;



OrderedPathsOfLengthN:= function( kQ, n )
	local x, y, L, Gens, VariableName, Cart, degreeN;
	if n = 0 then
		return [ One( kQ ) ];
	else
		L:= [ ];
		Gens:= GeneratorsOfAlgebra( kQ );
		VariableName:= Length( GeneratorsOfAlgebra( kQ ) );
		for x in Gens do
			if not x = One( kQ ) then
				Add( L, x );
			fi;
		od;
		Cart:= Tuples( L, n );
		degreeN:= [];
		for y in Cart do
			if not Product( y ) in degreeN and not Product( y ) = Zero( kQ ) then
				Add( degreeN, Product( y ) );
			fi;
		od;
		return degreeN ;
	fi;
end;



GradingOfAlgebraByRels:= function( kQ, rels )    #This function assumes that the ideal generated by rels intersects kQ_0 trivially and that rels is a set of homogeneous relations of kQ
	local Counter, I, A, DimTotal, ComponentList, DimOfComponents, gens, Grade ;
	A:= GBQuotient( kQ, rels );
	DimTotal:= Dimension( A );
	ComponentList:= [ ];
	DimOfComponents:= [ ];
	Counter:= 0 ;
	while Sum( DimOfComponents ) < DimTotal do
		gens:= OrderedPathsOfLengthN( A, Counter );
		Grade:= Subspace( A, gens );
		Add( ComponentList, [ Grade, Counter ] );
		Add( DimOfComponents, Dimension( Grade ) );
		Counter:= Counter + 1;
	od;
	if Sum( DimOfComponents ) = DimTotal then
		return [ A, ComponentList ] ;
	else
		return [ A, ComponentList, "The relations may not be homogeneous" ];
	fi;
end;



GradingOfAlgebra:= function( A )    #This function assumes that the ideal generated by rels intersects kQ_0 trivially and that rels is a set of homogeneous relations of kQ
	local Counter, I, kQ, rels, DimTotal, ComponentList, DimOfComponents, gens, Grade ;
	if IsFiniteDimensional( A ) = true then
		DimTotal:= Dimension( A );
		ComponentList:= [ ];
		DimOfComponents:= [ ];
		Counter:= 0 ;
		while Sum( DimOfComponents ) < DimTotal do
			gens:= OrderedPathsOfLengthN( A, Counter );
			Grade:= Subspace( A, gens );
			Add( ComponentList, [ Grade, Counter ] );
			Add( DimOfComponents, Dimension( Grade ) );
			Counter:= Counter + 1;
		od;
		if Sum( DimOfComponents ) = DimTotal then
			return [ A, ComponentList ] ;
		else
			return [ A, ComponentList, "The relations may not be homogeneous" ];
		fi;
	else
		Print("The algebra is not finite dimensional");
	fi;
end;



GradedPositionFinder:= function(GradedA, n)
	local x, ListA, L;
	L:= [ ];
	ListA:= GradedA[2];
	for x in ListA do
		if x[2] = n then
			Add( L, x[1] );
		else
			continue;
		fi;
	od;
	if L = [ ] then
		return TrivialSubspace( GradedA[1] );
	else
		return L[1];
	fi;
end;



GradedDimensionVerifier:= function( GradedA )
	local x, A, ListA, ListOfDims;
	A:= GradedA[1]; ListA:= GradedA[2];
	ListOfDims:= [ ];
	for x in ListA do
		Add( ListOfDims, Dimension( x[1] ) ) ;
	od;
	return [ Dimension( A ), Sum( ListOfDims ) ];
end;



BasisForGradedAlgebra:= function( GradedA )
	local A, L, x, NewBase;
	A:= GradedA[1];
	L:= [];
	for x in GradedA[2] do
		Add( L, BasisVectors( Basis( x[1] ) ) );
	od;
	NewBase:= Basis( A, Union( L ) );
	return NewBase;
end;


#################################################################################################################################################################################


TensorProductOfAlgebraNTimes:= function( A, n )
	local LesserTensor;
	if n = 0 then
		LesserTensor:= LeftActingDomain( A );
		return LesserTensor ;
	elif n = 1 then
		LesserTensor:= A ;
		return LesserTensor ;
	elif n = 2 then
		LesserTensor:= TensorProductOfAlgebras( A, A );
		return LesserTensor ;
	else
		LesserTensor:= TensorProductOfAlgebras( TensorProductOfAlgebraNTimes( A, n-1 ), A );
		return LesserTensor ;
	fi;
end;


SubspacesToTensorProduct:= function( AB, Ai, Bj ) #Takes subspaces Ai of A and Bj of B and returns the subspace Ai \otimes Bj of AB = A \otimes B
	local BasisAi, BasisBj, TensorBasis, iter, P, s, TensorSubspace ;
	BasisAi:= Basis( Ai );
	BasisBj:= Basis( Bj );
	TensorBasis:= [ ];
	iter:= IteratorOfCartesianProduct( BasisAi, BasisBj );
	for P in iter do
		s:= SimpleTensor( [ P[1], P[2] ], AB );
		Add( TensorBasis, s );
	od;
	TensorSubspace:= Subspace( AB, TensorBasis );
	return TensorSubspace ;
end;


nthGradeTensorProduct:= function( AB, GradedA, GradedB, n )
	local ListA, ListB, iter, P, GradedPart, nthGradeList, nthGrade ;
	nthGradeList:= [ ];
	ListA:= GradedA[2];
	ListB:= GradedB[2];
	iter:= IteratorOfCartesianProduct( ListA, ListB );
	for P in iter do
		if P[1][2] + P[2][2] = n then
			GradedPart:= SubspacesToTensorProduct( AB, P[1][1], P[2][1] );
			Add( nthGradeList, GradedPart );
		else
			continue;
		fi;
	od;
	nthGrade:= Sum( nthGradeList );
	return nthGrade;
end;


TensorProductOfGradedAlgebras:= function( GradedA, GradedB ) #AB is the tensor product of A and B, GradedA is a list [ A, L ], where L is the list outputted by NewGradingOfAlgebraByRels( kQ, rels )
	local A, B, AB, DimAB, ListA, ListB, GradesA, GradesB, x1, x2, x3, x4, iter, cart, IndexList, ABmin, ABmax, ABGrades, nthGrade ;
	A:= GradedA[1]; B:= GradedB[1];
	AB:= TensorProductOfAlgebras( A, B );
	DimAB:= Dimension( AB );
	ListA:= GradedA[2]; GradesA:= [ ];
	ListB:= GradedB[2]; GradesB:= [ ];
	for x1 in ListA do
		Add( GradesA, x1[2] );
	od;
	for x2 in ListB do
		Add( GradesB, x2[2] );
	od;
	cart:= Cartesian( GradesA, GradesB );
	IndexList:= [ ];
	for x3 in cart do
		Add( IndexList, Sum( x3 ) );
	od;
	ABmin:= Minimum( IndexList );
	ABmax:= Maximum( IndexList );
	ABGrades:= [ ];
	for x4 in [ABmin..ABmax] do
		nthGrade:= nthGradeTensorProduct( AB, GradedA, GradedB, x4 );
		Add( ABGrades, [ nthGrade, x4 ] );
	od;
	return [ AB, ABGrades ];
end;


TensorProductOfGradedAlgebraNTimes:= function( GradedA, n) 	#GradedA is a list of the form [ A, L ], where L is the grading of A.
	local TProduct, LesserTensorProduct, LLesser;
	if n = 2 then
		TProduct:= TensorProductOfGradedAlgebras( GradedA, GradedA );
		return TProduct;
	elif n > 2 then
		TProduct:= TensorProductOfGradedAlgebras( TensorProductOfGradedAlgebraNTimes( GradedA, n-1 ), GradedA );
		return TProduct ;
	else
		Print("what are you doing");
	fi;
end;


#TensorProductOfNGradedALgebras:= function( GradAlgList )
#	local n;
#end;


nSimpleTensor:= function( L, Tensor ) #L is a list of n elements a_n of A, and Tensor is the n-fold tensor product of A, as outputted by TensorProductOfAlgebraNTimes
	local n, LesserTensor, TensorElement;
	n:= Length( L );
	if n = 2 then
		TensorElement:= SimpleTensor( L, Tensor );
		return TensorElement;
	elif n > 2 then
		LesserTensor:= TensorProductDecomposition( Tensor )[1];
		TensorElement:= SimpleTensor( [ nSimpleTensor( L{[1..(n-1)]}, LesserTensor ), L[n] ], Tensor );
		return TensorElement;
	else
		Print("The list of elements must have length at least 2");
	fi;
end;


#################################################################################################################################################################################


IsTrue:= function( obj )
	if obj = true then
		return true;
	else
		return false;
	fi;
end;


IsLinearMapOfDegreeN:= function( f, GradedA, GradedB, n )
	local A, B, ListA, ListB, NewListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, c, x1, x2, x3, x4, x5, x6, i, MaxCounter, MinCounter, ImageList, L, TruthList, t ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
#
	IndexA:= [ ]; IndexB:= [ ];
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	MaxCounter:= Bmax + 1; MinCounter:= Bmin - 1;
	NewListB:= ShallowCopy( ListB );
	c:= Length( ListA ) + AbsInt(n)*2;
	for x3 in [1..c] do												#Need to add a considerable amount of trivial graded parts to B to make the function verify degree well
		Add( NewListB, [ TrivialSubspace( B ), MaxCounter ] );
		Add( NewListB, [ TrivialSubspace( B ), MinCounter ] );
		MaxCounter:= MaxCounter + 1; MinCounter:= MinCounter - 1;
	od;
#
	ImageList:= [ ];
	for i in [Amin..Amax] do										#This part makes pairs [ B_{i+n}, f(Ai) ], for graded parts Bj and Ai of B and A, respectively, so that
		L:= [ ];																	#we may use IsSubset afterwards on this list.
		for x4 in NewListB do
			if x4[2] = n + i then
				Add( L, x4[1] );
			else
				continue;
			fi;
		od;
		for x5 in ListA do
			if x5[2] = i then
				Add( L, Image( f, x5[1] ) );
			else
				continue;
			fi;
		od;
		Add( ImageList, L );
	od;
#
	TruthList:= [ ];												#This part is needed since the ForAll function only works on unary functions
	for x6 in ImageList do
		Add( TruthList, IsSubset( x6[1], x6[2] ) );
	od;
	t:= ForAll( TruthList, IsTrue );
return t;
end;


ExtendLinearMap:= function( f, GradedA, GradedB ) #This function inputs a map f: Ai -> Bj and extends it to a map f: A -> B in a natural way
	local x1, x2, x3, x4, A, B, ListA, ListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, fBase, BaseList, ExtendedBase, ImageList, ExtendedMap ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
#
	if IsSubset( A, Source(f) ) = true and IsSubset( B, Range(f) ) = true then
		fBase:= Basis( Source( f ) );
		BaseList:= [ ];
		for x3 in ListA do
			Add( BaseList, Basis( x3[1] ) );
		od;
		ExtendedBase:= Union( BaseList );
		ExtendedBase:= Basis( A, ExtendedBase );
		ImageList:= [ ];
		for x4 in ExtendedBase do
			if x4 in Source( f ) then
				Add( ImageList, Image( f, x4 ) );
			else
				Add( ImageList, Zero( B ) );
			fi;
		od;
		ExtendedMap:= LeftModuleHomomorphismByImages( A, B, ExtendedBase, ImageList );
		return ExtendedMap;
	else
		Print("The domain of the entered map must be contained in the first space, and its range must be contained in the second space");
	fi;
end;


ExtendedHomSpace:= function( HomAiBj, HomAB, GradedA, GradedB )				#Takes a Hom set Hom(Ai, Bj) and considers it as a subspace of Hom(A, B)
	local x1, f, A, B, ListA, ListB, BaseAiBj, ExtendedBaseAiBj, NewHom ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	BaseAiBj:= Basis( HomAiBj );
	ExtendedBaseAiBj:= [ ];
	for x1 in BaseAiBj do
		f:= ExtendLinearMap( x1, GradedA, GradedB );
		Add( ExtendedBaseAiBj, f );
	od;
	NewHom:= Subspace( HomAB, ExtendedBaseAiBj );
	return NewHom;
end;


nthGradedHom:= function( K, HomAB, GradedA, GradedB, n )   #This function outputs the nth graded Hom set Hom( A, B )_n of linear maps A -> B of degree n
	local c, x1, x2, x3, x4, x5, i, j, A, B, Ai, Bj, ListA, ListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, MaxCounter, MinCounter, NewListB, HomList, HomAiBj, NewHom ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	IndexA:= [ ]; IndexB:= [ ];
#
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	MaxCounter:= Bmax + 1; MinCounter:= Bmin - 1;
	NewListB:= ShallowCopy( ListB );
	c:= Length( ListA ) + AbsInt(n)*2;
	for x3 in [1..c] do												#Need to add a considerable amount of trivial graded parts to B to make the function compute well
		Add( NewListB, [ TrivialSubspace( B ), MaxCounter ] );
		Add( NewListB, [ TrivialSubspace( B ), MinCounter ] );
		MaxCounter:= MaxCounter + 1; MinCounter:= MinCounter - 1;
	od;
#
	HomList:= [ ];													#Because we are looking at linear maps of degree n, we need to take the Hom space Hom(A_i, B_{i+n}) for each nonzero A_i.
	for x4 in ListA do
		i:= x4[2]; Ai:= x4[1];
		j:= i + n;
		for x5 in NewListB do
			if x5[2] = j then
				Bj:= x5[1];
			else
				continue;
			fi;
		od;
		HomAiBj:= Hom( K, Ai, Bj );
		NewHom:= ExtendedHomSpace( HomAiBj, HomAB, GradedA, GradedB );	#"Extends" the space Hom(A_i, B_{i+n}) to a subspace of Hom(A, B)
		Add( HomList, NewHom );
	od;
	return Sum( HomList );
end;


HOMGrading:= function( K, GradedA, GradedB ) #This function returns the grading of HOM(A, B) = \bigoplus_{n \in \mathbb{Z}} Hom(A, B)_n
	local n, x1, x2, x3, x4, x5, A, B, HomAB, ListA, ListB, IndexA, IndexB, Amin, Amax, Bmin, Bmax, MaxCounter, MinCounter, HOMMax, HOMMin, HomGrades, nGrade ;
	A:= GradedA[1]; ListA:= GradedA[2];
	B:= GradedB[1]; ListB:= GradedB[2];
	HomAB:= Hom( K, A, B );
	IndexA:= [ ]; IndexB:= [ ];
#
	for x1 in ListA do
		Add( IndexA, x1[2] );
	od;
	Amin:= Minimum( IndexA ); Amax:= Maximum( IndexA );
#
	for x2 in ListB do
		Add( IndexB, x2[2] );
	od;
	Bmin:= Minimum( IndexB ); Bmax:= Maximum( IndexB );
#
	HOMMax:= Bmax - Amin; HOMMin:= Bmin - Amax;
	HomGrades:= [ ];
	for n in [HOMMin..HOMMax] do
		nGrade:= nthGradedHom( K, HomAB, GradedA, GradedB, n );
		Add( HomGrades, [ nGrade, n ] );
	od;
	return [ HomAB, HomGrades ];
end;


#################################################################################################################################################################################



ImageOfBarDifferential:= function( f, n, A, An1, An )  #f is a linear map An -> A, for An the n-fold tensor product of A
	local i, x, L, BaseA, BaseATuples, ImagesbfList, elmt, summand, bfSummand, bf, BaseAn1;
	BaseA:= Basis( A );
	BaseATuples:= Tuples( BaseA, n + 1 );
	ImagesbfList:= [ ];
	for x in BaseATuples do
#		L:= [ ];
		L:= [ x[1] * Image( f, nSimpleTensor( x{[2..n+1]}, An ) ) ];
		for i in [1..n] do
			elmt:= Concatenation( x{[1..(i-1)]}, [ x[i] * x[i+1] ], x{[(i+2)..(n+1)]} );
			summand:= nSimpleTensor( elmt, An );
			bfSummand:= ((-1)^i ) * Image( f, summand );
			Add( L, bfSummand );
		od;
		Add( L, ((-1)^(n+1)) * Image( f, nSimpleTensor( x{[1..n]}, An ) ) * x[n+1] );
		Add( ImagesbfList, Sum( L ) );
	od;
	BaseAn1:= Basis( An1 );
	bf:= LeftModuleHomomorphismByImages( An1, A, BaseAn1, ImagesbfList );
	return bf;
end;


BarDifferential:= function( GradedA, n )
	local A, An, An1, GradedAn, GradedAn1, HomAn, HomAn1, GradedHomAn, GradedHomAn1, ImageList, BaseHomAn, bImage, f, b;
	if n > 0 or n = 0 then
		A:= GradedA[1];
		GradedAn:= TensorProductOfGradedAlgebraNTimes( GradedA, n + 1 ); An:= GradedAn[1];
		GradedAn1:= TensorProductOfGradedAlgebraNTimes( GradedA, n + 2 ); An1:= GradedAn1[1];
		GradedHomAn:= HOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= HOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn:= Basis( HomAn );
		ImageList:= [ ];
		for f in BaseHomAn do
			bImage:= ImageOfBarDifferential( f, n + 1, A, An1, An );
			Add( ImageList, bImage );
		od;
		b:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList );
		return [ GradedHomAn, b, GradedHomAn1 ];
	else
		Print("Put in a correct number, dummy");
	fi;
end;


CoHHomologyMaps2:= function( GradedA, n )
	local f, g, GradedAn0, GradedAn, GradedAn1, A, An0, An, An1, GradedHomAn0, GradedHomAn, GradedHomAn1, HomAn0, HomAn, HomAn1, BaseHomAn0, BaseHomAn, ImageList1, ImageList2, bImage, b, bn0, bn;
	if n > 0 then
		A:= GradedA[1];
#b_n: Hom( A^{n+1}, A ) -> Hom( A^{n+2}, A )#
		GradedAn0:= TensorProductOfGradedAlgebraNTimes( GradedA, n ); An0:= GradedAn0[1];
		GradedAn:= TensorProductOfGradedAlgebraNTimes( GradedA, n + 1 ); An:= GradedAn[1];
		GradedAn1:= TensorProductOfGradedAlgebraNTimes( GradedA, n + 2 ); An1:= GradedAn1[1];
		GradedHomAn0:= HOMGrading( LeftActingDomain( A ), GradedAn0, GradedA ); HomAn0:= GradedHomAn0[1];
		GradedHomAn:= HOMGrading( LeftActingDomain( A ), GradedAn, GradedA ); HomAn:= GradedHomAn[1];
		GradedHomAn1:= HOMGrading( LeftActingDomain( A ), GradedAn1, GradedA ); HomAn1:= GradedHomAn1[1];
		BaseHomAn0:= Basis( HomAn0 );
		BaseHomAn:= Basis( HomAn );
		ImageList1:= [ ]; ImageList2:= [ ];
		for f in BaseHomAn0 do
			bImage:= ImageOfBarDifferential( f, n, A, An, An0 );
			Add( ImageList1, bImage );
		od;
		bn0:= LeftModuleHomomorphismByImages( HomAn0, HomAn, BaseHomAn0, ImageList1 );
		for g in BaseHomAn do
			bImage:= ImageOfBarDifferential( g, n+1, A, An1, An );
			Add( ImageList2, bImage );
		od;
		bn:= LeftModuleHomomorphismByImages( HomAn, HomAn1, BaseHomAn, ImageList2 );
		return [ bn, bn0, GradedHomAn0, GradedHomAn, GradedHomAn1 ];
	elif n = 0 then
		b:= BarDifferential( GradedA, 0 )[2];
		return b;
	else
		Print("Enter a nonnegative integer");
	fi;
end;


GradedCoHHomology:= function( GradedHomAn, nKernelImage, i ) #nKernelImage is a list [ K, I ], for K the kernel of the nth differential and I the image of the (n-1)th differential
	local A, Ai, iKer, iIm;
	Ai:= GradedPositionFinder( GradedHomAn, i );
	iKer:= Intersection( nKernelImage[1], Ai );
	iIm:= Intersection( nKernelImage[2], Ai );
	return iKer/iIm;
end;
